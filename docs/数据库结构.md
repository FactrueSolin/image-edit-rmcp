S3确实是扁平存储（键值对），但**通过key的斜杠模拟目录结构**是标准做法。针对你的需求——存储处理后的图像+缓存元数据，建议如下：

## 推荐目录结构

```
bucket/
├── images/
│   └── {hash}/                    # 用原图hash作为唯一标识
│       ├── original.{ext}         # 原图（可选保留）
│       ├── crop_100x100.png       # 处理后的图
│       ├── rotate_90.png
│       └── meta.json              # 缓存元数据
│
└── cache/
    └── {operation_hash}.json      # 或用操作签名做key
```

## 关键设计

| 层级           | 作用                                        |
| -------------- | ------------------------------------------- |
| `{hash}`       | 原图的SHA256/MD5，保证同一图片不重复处理    |
| `meta.json`    | 存储已完成的操作列表、URL映射、过期时间     |
| 文件名编码操作 | 如 `crop_100x100.png`，直接从文件名解析参数 |

## meta.json 示例

```json
{
  "originalUrl": "https://example.com/photo.jpg",
  "createdAt": "2026-01-23T18:00:00Z",
  "operations": {
    "crop_100x100": {
      "key": "images/abc123/crop_100x100.png",
      "url": "https://s3.sereniblue.com/bucket/images/abc123/crop_100x100.png",
      "createdAt": "2026-01-23T18:05:00Z"
    },
    "rotate_90": {
      "key": "images/abc123/rotate_90.png",
      "url": "https://s3.sereniblue.com/bucket/images/abc123/rotate_90.png"
    }
  }
}
```

## 工作流程

1. **请求处理图片** → 计算原图hash
2. **检查缓存** → `GET images/{hash}/meta.json`
3. **命中** → 直接返回已有URL
4. **未命中** → 处理图片 → 上传 → 更新meta.json

## URL生成

如果S3配置了公开读取，URL就是：
```
{S3_HOST}/{bucket}/images/{hash}/{filename}
```

否则需要生成**预签名URL**（有效期可控），`aws4fetch`也支持。

## 一句话小结

用 `images/{原图hash}/{操作描述}.ext` 存图，配合 `meta.json` 做缓存索引，hash保证幂等，文件名自描述操作类型。